# Arquitectura de Software
- Definición: La arquitectura de software es la estructura fundamental de un sistema de software, que incluye sus componentes, las relaciones entre ellos y las propiedades que son esenciales para cumplir con los requisitos del sistema. Nos permite guiar el diseño y la organización del software.
- Importancia de la arquitectura de software:
    - Escalabilidad: Facilita el crecimiento del sistema, como añadir nuevas funcionalidades o manejar más usuarios.
    - Mantenibilidad: Permite realizar cambios y actualizaciones de manera eficiente, sin afectar todo el sistema.
    - Desempeño: Optimiza el rendimiento del software, asegurando que funcione de manera rápida y eficiente.
    - Reusabilidad: Promueve la reutilización de componentes y módulos.
## Componentes clave de la arquitectura de software
- Componentes: Son las unidades funcionales del sistema, como módulos, interfaces, datos y servicios.
- Relaciones: Cómo interactúan los componentes entre sí, incluyendo la comunicación y la dependencia.
- Los tipos de componentes:
    - Módulos: Son partes independientes del sistema que realizan funciones específicas.
    - Intefaces: Puntos de interacción entre diferentes componentes o sistemas.
    - Datos: Información que se procesa y almacena en el sistema.
    - Servicios: Funcionalidades que el sistema ofrece a los usuarios o a otros sistemas.
## Estilos arquitectónicos comunes
- Estilo: Conjunto de principios y patrones para diseñar la arquitectura de software.
- Ejemplos: Arquitecura en capas, arquitectura cliente-servidor, arquitectura orientada a servicios (SOA), arquitectura basada en microservicios.
- Tipos de estilos arquitectura:
    ### Comunicación
    - **SOA (Arquitectura Orientada a Servicios)**: Los servicios se comunican a través de interfaces bien definidas. Ejemplo: Un sistema bancario donde servicios independientes manejan cuentas, transacciones y préstamos.
    - **Bus de mensajes**: Los componentes se comunican mediante un bus central de mensajes. Ejemplo: Sistema de comercio electrónico donde pedidos, inventario y facturación se comunican a través de un bus de mensajes.
    
    ### Despliegue
    - **Cliente/Servidor**: Separación entre el cliente que solicita servicios y el servidor que los proporciona. Ejemplo: Aplicación web donde el navegador (cliente) solicita datos al servidor web.
    - **N-Tier (N-Capas)**: Sistema organizado en múltiples niveles lógicos. Ejemplo: Aplicación de 3 capas con presentación, lógica de negocio y acceso a datos.
    
    ### Dominio
    - **Diseño impulsado por dominio (DDD)**: La arquitectura se basa en el modelo del dominio de negocio. Ejemplo: Sistema de gestión hospitalaria organizado alrededor de conceptos como Paciente, Doctor, Cita médica.
    
    ### Estructura
    - **Arquitectura basada en componentes**: Sistema construido con componentes reutilizables e independientes. Ejemplo: Framework como React donde cada componente UI es independiente.
    - **Arquitectura orientada a objetos**: Sistema basado en objetos que encapsulan datos y comportamiento. Ejemplo: Sistema de gestión de biblioteca con clases Libro, Usuario, Préstamo.
    - **Arquitectura en capas**: Sistema organizado en capas horizontales. Ejemplo: Aplicación empresarial con capas de presentación, lógica de negocio, acceso a datos y persistencia.

## Uso práctico de los estilos arquitectónicos

### ¿Para qué se usan estos estilos arquitectónicos?
**No es solo para diagramas** - estos estilos se usan para:
- Organizar el código real (carpetas, packages, módulos)
- Decidir cómo estructurar tu proyecto
- Definir cómo los componentes se comunican
- Planificar el despliegue del sistema

### ¿Por qué están separados en esas 4 categorías?

#### **Comunicación** - ¿Cómo hablan los componentes?

**Estructura de carpetas:**
```
Ejemplo práctico:
proyecto/
├── services/           # SOA - cada servicio independiente
│   ├── user-service/
│   ├── order-service/
│   └── payment-service/
└── message-bus/        # Bus de mensajes - comunicación central
```

**Diagrama SOA:**
```
[User Service] ←→ [Interface] ←→ [Order Service]
       ↕                              ↕
[Database]                    [Payment Service]
```

**Diagrama Bus de Mensajes:**
```
[Pedidos] ←→ [Message Bus] ←→ [Inventario]
                  ↕
            [Facturación]
```

#### **Despliegue** - ¿Dónde y cómo se ejecuta?

**Estructura de carpetas:**
```
Cliente/Servidor:
frontend/               # Se despliega en navegador
backend/               # Se despliega en servidor

N-Tier:
├── presentation/      # Capa 1 - UI
├── business/         # Capa 2 - Lógica de negocio  
└── data/            # Capa 3 - Base de datos
```

**Diagrama Cliente/Servidor:**
```
[Cliente Web] ←→ HTTP ←→ [Servidor Web] ←→ [Base de Datos]
[Cliente Móvil] ←→ API ←→
```

**Diagrama N-Tier:**
```
[Capa Presentación] 
        ↓
[Capa Lógica Negocio]
        ↓
[Capa Acceso Datos]
        ↓
[Base de Datos]
```

#### **Dominio** - ¿Cómo organizas según el negocio?

**Estructura de carpetas:**
```
DDD Ejemplo:
src/
├── user/             # Dominio Usuario
├── order/           # Dominio Pedidos
├── payment/         # Dominio Pagos
└── inventory/       # Dominio Inventario
```

**Diagrama DDD:**
```
┌─────────────┐  ┌─────────────┐
│   Usuario   │  │   Pedido    │
│             │  │             │
│ - login()   │  │ - crear()   │
│ - logout()  │  │ - cancelar()│
└─────────────┘  └─────────────┘
       │                │
       └── realiza ─────┘
                │
        ┌─────────────┐
        │    Pago     │
        │             │
        │ - procesar()│
        │ - validar() │
        └─────────────┘
```

#### **Estructura** - ¿Cómo organizas el código?

**Estructura de carpetas:**
```
Por componentes:
components/
├── Header/
├── Footer/
└── ProductList/

En capas:
src/
├── controllers/     # Capa presentación
├── services/       # Capa negocio
└── repositories/   # Capa datos
```

**Diagrama por Componentes:**
```
┌───────────────────────┐
│      <Header/>        │
├───────────────────────┤
│   <ProductList/>      │
│  ┌─────────────────┐  │
│  │ <ProductCard/>  │  │
│  │ <ProductCard/>  │  │
│  └─────────────────┘  │
├───────────────────────┤
│      <Footer/>        │
└───────────────────────┘
```

**Diagrama en Capas:**
```
┌─────────────────┐
│  Controllers    │ ← HTTP Requests
├─────────────────┤
│    Services     │ ← Business Logic
├─────────────────┤
│  Repositories   │ ← Data Access
├─────────────────┤
│   Database      │ ← Data Storage
└─────────────────┘
```

**Resumen**: Estas arquitecturas te ayudan tanto a organizar tu código real como a visualizar la estructura del sistema mediante diagramas.

## Diseño de interfaces y comunicación
- El diseño de interfaces define cómo los componentes interactúan entre sí.
- Protocolos comunes: REST, SOAP, gRPC, WebSockets.
- Comunicación: Protocolos y métodos de intercambio de datos entre componentes.

## Gestión de la complejidad
- La gestión de la complejidad implica dividir el sistema en módulos manejables, facilitando el desarrollo y mantenimiento.
- Abstracción: Ocultar detalles complejos y mostrar solo lo esencial.

## Principios de la Programación Orientada a Objetos

### 1. Abstracción
- **¿Qué es?**: Simplificar la complejidad mostrando solo lo esencial y ocultando los detalles complejos del funcionamiento interno.
- **Se implementa principalmente de dos formas:**

**Clases abstractas:**
- Se declaran con la palabra clave `abstract`
- Pueden contener métodos abstractos (sin cuerpo) y métodos concretos (con implementación)
- No se pueden instanciar directamente
- sin cuerpo se refieren a métodos que deben ser implementados por las clases derivadas
```java
abstract class Vehiculo {
    abstract void acelerar(); // Método abstracto
    
    void encender() {         // Método concreto
        System.out.println("Vehículo encendido");
    }
}
```

**Interfaces:**
- Definen un contrato que las clases deben cumplir
- Todos los métodos son abstractos por defecto
- Una clase puede implementar múltiples interfaces
```java
interface Conducible {
    void acelerar();
    void frenar();
}
```

### 2. Encapsulación
- **¿Qué es?**: Ocultar los datos internos de un objeto y solo permitir acceso a través de métodos controlados (getters y setters).
- **Beneficio**: Protege la integridad de los datos y controla cómo se modifican.
```java
public class CuentaBancaria {
    private double saldo; // Dato privado, no accesible directamente
    
    public void depositar(double cantidad) {
        if (cantidad > 0) {
            saldo += cantidad; // Acceso controlado
        }
    }
    
    public double getSaldo() {
        return saldo; // Solo lectura del saldo
    }
}
```

### 3. Herencia
- **¿Qué es?**: Permite que una clase "hija" herede atributos y métodos de una clase "padre", reutilizando código.
- **Beneficio**: Evita repetir código y establece relaciones entre clases.
```java
class Persona {
    protected String nombre;
    protected int edad;
    
    public void presentarse() {
        System.out.println("Soy " + nombre);
    }
}

class Estudiante extends Persona { // Hereda de Persona
    private String carrera;
    
    public void estudiar() {
        System.out.println(nombre + " está estudiando " + carrera);
    }
}
```

### 4. Polimorfismo
- **¿Qué es?**: Permite que objetos de diferentes clases respondan de manera diferente al mismo método.
- **Beneficio**: Un mismo código puede trabajar con diferentes tipos de objetos.
```java
interface Animal {
    void hacerSonido();
}

class Perro implements Animal {
    public void hacerSonido() {
        System.out.println("Guau guau");
    }
}

class Gato implements Animal {
    public void hacerSonido() {
        System.out.println("Miau");
    }
}

// Polimorfismo en acción:
Animal miAnimal = new Perro();
miAnimal.hacerSonido(); // Imprime "Guau guau"
```

## Términos comunes
- Patrón de diseño: Solución reutilizable a un problema común en el diseño de software.
- Componente: es una unidad funcional del sistema.

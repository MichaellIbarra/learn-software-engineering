# Arquitectura de Software
- Definición: La arquitectura de software es la estructura fundamental de un sistema de software, que incluye sus componentes, las relaciones entre ellos y las propiedades que son esenciales para cumplir con los requisitos del sistema. Nos permite guiar el diseño y la organización del software.
- Importancia de la arquitectura de software:
    - Escalabilidad: Facilita el crecimiento del sistema, como añadir nuevas funcionalidades o manejar más usuarios.
    - Mantenibilidad: Permite realizar cambios y actualizaciones de manera eficiente, sin afectar todo el sistema.
    - Desempeño: Optimiza el rendimiento del software, asegurando que funcione de manera rápida y eficiente.
    - Reusabilidad: Promueve la reutilización de componentes y módulos.
## Componentes clave de la arquitectura de software
- Componentes: Son las unidades funcionales del sistema, como módulos, interfaces, datos y servicios.
- Relaciones: Cómo interactúan los componentes entre sí, incluyendo la comunicación y la dependencia.
- Los tipos de componentes:
    - Módulos: Son partes independientes del sistema que realizan funciones específicas.
    - Intefaces: Puntos de interacción entre diferentes componentes o sistemas.
    - Datos: Información que se procesa y almacena en el sistema.
    - Servicios: Funcionalidades que el sistema ofrece a los usuarios o a otros sistemas.
## Estilos arquitectónicos comunes
- Estilo: Conjunto de principios y patrones para diseñar la arquitectura de software.
- Ejemplos: Arquitecura en capas, arquitectura cliente-servidor, arquitectura orientada a servicios (SOA), arquitectura basada en microservicios.
- Tipos de estilos arquitectura:
    ### Comunicación
    - **SOA (Arquitectura Orientada a Servicios)**: Los servicios se comunican a través de interfaces bien definidas. Ejemplo: Un sistema bancario donde servicios independientes manejan cuentas, transacciones y préstamos.
    - **Bus de mensajes**: Los componentes se comunican mediante un bus central de mensajes. Ejemplo: Sistema de comercio electrónico donde pedidos, inventario y facturación se comunican a través de un bus de mensajes.
    
    ### Despliegue
    - **Cliente/Servidor**: Separación entre el cliente que solicita servicios y el servidor que los proporciona. Ejemplo: Aplicación web donde el navegador (cliente) solicita datos al servidor web.
    - **N-Tier (N-Capas)**: Sistema organizado en múltiples niveles lógicos. Ejemplo: Aplicación de 3 capas con presentación, lógica de negocio y acceso a datos.
    
    ### Dominio
    - **Diseño impulsado por dominio (DDD)**: La arquitectura se basa en el modelo del dominio de negocio. Ejemplo: Sistema de gestión hospitalaria organizado alrededor de conceptos como Paciente, Doctor, Cita médica.
    
    ### Estructura
    - **Arquitectura basada en componentes**: Sistema construido con componentes reutilizables e independientes. Ejemplo: Framework como React donde cada componente UI es independiente.
    - **Arquitectura orientada a objetos**: Sistema basado en objetos que encapsulan datos y comportamiento. Ejemplo: Sistema de gestión de biblioteca con clases Libro, Usuario, Préstamo.
    - **Arquitectura en capas**: Sistema organizado en capas horizontales. Ejemplo: Aplicación empresarial con capas de presentación, lógica de negocio, acceso a datos y persistencia.

## Uso práctico de los estilos arquitectónicos

### ¿Para qué se usan estos estilos arquitectónicos?
**No es solo para diagramas** - estos estilos se usan para:
- Organizar el código real (carpetas, packages, módulos)
- Decidir cómo estructurar tu proyecto
- Definir cómo los componentes se comunican
- Planificar el despliegue del sistema

### ¿Por qué están separados en esas 4 categorías?

#### **Comunicación** - ¿Cómo hablan los componentes?

**Estructura de carpetas:**
```
Ejemplo práctico:
proyecto/
├── services/           # SOA - cada servicio independiente
│   ├── user-service/
│   ├── order-service/
│   └── payment-service/
└── message-bus/        # Bus de mensajes - comunicación central
```

**Diagrama SOA:**
```
[User Service] ←→ [Interface] ←→ [Order Service]
       ↕                              ↕
[Database]                    [Payment Service]
```

**Diagrama Bus de Mensajes:**
```
[Pedidos] ←→ [Message Bus] ←→ [Inventario]
                  ↕
            [Facturación]
```

#### **Despliegue** - ¿Dónde y cómo se ejecuta?

**Estructura de carpetas:**
```
Cliente/Servidor:
frontend/               # Se despliega en navegador
backend/               # Se despliega en servidor

N-Tier:
├── presentation/      # Capa 1 - UI
├── business/         # Capa 2 - Lógica de negocio  
└── data/            # Capa 3 - Base de datos
```

**Diagrama Cliente/Servidor:**
```
[Cliente Web] ←→ HTTP ←→ [Servidor Web] ←→ [Base de Datos]
[Cliente Móvil] ←→ API ←→
```

**Diagrama N-Tier:**
```
[Capa Presentación] 
        ↓
[Capa Lógica Negocio]
        ↓
[Capa Acceso Datos]
        ↓
[Base de Datos]
```

#### **Dominio** - ¿Cómo organizas según el negocio?

**Estructura de carpetas:**
```
DDD Ejemplo:
src/
├── user/             # Dominio Usuario
├── order/           # Dominio Pedidos
├── payment/         # Dominio Pagos
└── inventory/       # Dominio Inventario
```

**Diagrama DDD:**
```
┌─────────────┐  ┌─────────────┐
│   Usuario   │  │   Pedido    │
│             │  │             │
│ - login()   │  │ - crear()   │
│ - logout()  │  │ - cancelar()│
└─────────────┘  └─────────────┘
       │                │
       └── realiza ─────┘
                │
        ┌─────────────┐
        │    Pago     │
        │             │
        │ - procesar()│
        │ - validar() │
        └─────────────┘
```

#### **Estructura** - ¿Cómo organizas el código?

**Estructura de carpetas:**
```
Por componentes:
components/
├── Header/
├── Footer/
└── ProductList/

En capas:
src/
├── controllers/     # Capa presentación
├── services/       # Capa negocio
└── repositories/   # Capa datos
```

**Diagrama por Componentes:**
```
┌───────────────────────┐
│      <Header/>        │
├───────────────────────┤
│   <ProductList/>      │
│  ┌─────────────────┐  │
│  │ <ProductCard/>  │  │
│  │ <ProductCard/>  │  │
│  └─────────────────┘  │
├───────────────────────┤
│      <Footer/>        │
└───────────────────────┘
```

**Diagrama en Capas:**
```
┌─────────────────┐
│  Controllers    │ ← HTTP Requests
├─────────────────┤
│    Services     │ ← Business Logic
├─────────────────┤
│  Repositories   │ ← Data Access
├─────────────────┤
│   Database      │ ← Data Storage
└─────────────────┘
```

**Resumen**: Estas arquitecturas te ayudan tanto a organizar tu código real como a visualizar la estructura del sistema mediante diagramas.

## Diseño de interfaces y comunicación
- El diseño de interfaces define cómo los componentes interactúan entre sí.
- Protocolos comunes: REST, SOAP, gRPC, WebSockets.
- Comunicación: Protocolos y métodos de intercambio de datos entre componentes.

## Gestión de la complejidad
- La gestión de la complejidad implica dividir el sistema en módulos manejables, facilitando el desarrollo y mantenimiento.
- Abstracción: Ocultar detalles complejos y mostrar solo lo esencial.

## Principios de la Programación Orientada a Objetos

### 1. Abstracción
- **¿Qué es?**: Simplificar la complejidad mostrando solo lo esencial y ocultando los detalles complejos del funcionamiento interno.
- **Se implementa principalmente de dos formas:**

**Clases abstractas:**
- Se declaran con la palabra clave `abstract`
- Pueden contener métodos abstractos (sin cuerpo) y métodos concretos (con implementación)
- No se pueden instanciar directamente
- sin cuerpo se refieren a métodos que deben ser implementados por las clases derivadas
```java
abstract class Vehiculo {
    abstract void acelerar(); // Método abstracto
    
    void encender() {         // Método concreto
        System.out.println("Vehículo encendido");
    }
}
```

**Interfaces:**
- Definen un contrato que las clases deben cumplir
- Todos los métodos son abstractos por defecto
- Una clase puede implementar múltiples interfaces
```java
interface Conducible {
    void acelerar();
    void frenar();
}
```

### 2. Encapsulación
- **¿Qué es?**: Ocultar los datos internos de un objeto y solo permitir acceso a través de métodos controlados (getters y setters).
- **Beneficio**: Protege la integridad de los datos y controla cómo se modifican.
```java
public class CuentaBancaria {
    private double saldo; // Dato privado, no accesible directamente
    
    public void depositar(double cantidad) {
        if (cantidad > 0) {
            saldo += cantidad; // Acceso controlado
        }
    }
    
    public double getSaldo() {
        return saldo; // Solo lectura del saldo
    }
}
```

### 3. Herencia
- **¿Qué es?**: Permite que una clase "hija" herede atributos y métodos de una clase "padre", reutilizando código.
- **Beneficio**: Evita repetir código y establece relaciones entre clases.
```java
class Persona {
    protected String nombre;
    protected int edad;
    
    public void presentarse() {
        System.out.println("Soy " + nombre);
    }
}

class Estudiante extends Persona { // Hereda de Persona
    private String carrera;
    
    public void estudiar() {
        System.out.println(nombre + " está estudiando " + carrera);
    }
}
```

### 4. Polimorfismo
- **¿Qué es?**: Permite que objetos de diferentes clases respondan de manera diferente al mismo método.
- **Beneficio**: Un mismo código puede trabajar con diferentes tipos de objetos.
```java
interface Animal {
    void hacerSonido();
}

class Perro implements Animal {
    public void hacerSonido() {
        System.out.println("Guau guau");
    }
}

class Gato implements Animal {
    public void hacerSonido() {
        System.out.println("Miau");
    }
}

// Polimorfismo en acción:
Animal miAnimal = new Perro();
miAnimal.hacerSonido(); // Imprime "Guau guau"
```
## Patrón Arquitectónico (Architectural Pattern)

### Definición y Conceptos Fundamentales
- **¿Qué es?**: Un patrón arquitectónico es una solución general, probada y reutilizable para problemas recurrentes en el diseño de la arquitectura de software. Define la estructura fundamental del sistema y las relaciones entre sus componentes principales.

- **Propósito principal**: 
  - Proveer una estructura organizativa coherente para el sistema
  - Facilitar la comunicación entre desarrolladores mediante un vocabulario común
  - Mejorar la mantenibilidad, escalabilidad y comprensión del sistema
  - Reducir la complejidad arquitectónica mediante soluciones probadas

- **Diferencia con patrones de diseño**: Los patrones arquitectónicos operan a nivel de sistema completo, mientras que los patrones de diseño se enfocan en problemas específicos de código a menor escala.

### Clasificación de Patrones Arquitectónicos

#### 1. Patrones de Organización Estructural

**Patrón en Capas (Layered Pattern)**
- **Estructura**: El sistema se organiza en capas jerárquicas horizontales, cada una con responsabilidades específicas
- **Capas típicas**: 
  - Presentación (UI/interfaz de usuario)
  - Lógica de negocio (reglas del dominio)
  - Acceso a datos (persistencia)
  - Base de datos (almacenamiento)
- **Ventajas**: Separación clara de responsabilidades, fácil mantenimiento, reutilización de capas
- **Desventajas**: Posible latencia por comunicación entre capas, dependencias rígidas
- **Ejemplo**: Aplicaciones empresariales tradicionales, sistemas web MVC

**Patrón Cliente-Servidor**
- **Estructura**: División clara entre clientes (solicitan servicios) y servidores (proveen servicios)
- **Características**: 
  - Centralización de recursos y lógica en el servidor
  - Múltiples clientes pueden acceder simultáneamente
  - Comunicación mediante protocolos de red (HTTP, TCP, etc.)
- **Ventajas**: Centralización de datos, facilidad de gestión, seguridad centralizada
- **Desventajas**: Punto único de fallo, posible cuello de botella en el servidor
- **Ejemplo**: Aplicaciones web, sistemas de base de datos, aplicaciones móviles con backend

#### 2. Patrones de Distribución y Escalabilidad

**Patrón Monolítico**
- **Estructura**: Todo el sistema funcional está contenido en una única aplicación desplegable
- **Características**:
  - Una sola base de código
  - Despliegue como unidad única
  - Comunicación interna directa (llamadas a métodos)
- **Ventajas**: 
  - Simplicidad de desarrollo inicial
  - Fácil testing y debugging
  - Despliegue sencillo
  - Mejor rendimiento (no hay latencia de red interna)
- **Desventajas**: 
  - Escalabilidad limitada (todo o nada)
  - Dificultad de mantenimiento en aplicaciones grandes
  - Tecnología única para todo el sistema
- **Ejemplo**: Aplicaciones web tradicionales, sistemas internos pequeños a medianos

**Patrón de Microservicios**
- **Estructura**: La aplicación se descompone en servicios pequeños e independientes
- **Características**:
  - Cada servicio maneja un dominio de negocio específico
  - Comunicación mediante protocolos ligeros (HTTP/REST, gRPC)
  - Despliegue independiente por servicio
  - Bases de datos separadas por servicio
- **Ventajas**: 
  - Escalabilidad granular e independiente
  - Flexibilidad tecnológica (diferentes lenguajes por servicio)
  - Equipos independientes por servicio
  - Resistencia a fallos (aislamiento de servicios)
- **Desventajas**: 
  - Mayor complejidad operacional
  - Latencia de red entre servicios
  - Gestión compleja de transacciones distribuidas
  - Monitoreo y debugging más difícil
- **Ejemplo**: Aplicaciones de gran escala como Netflix, Amazon, sistemas de e-commerce modernos

## El Modelado de Arquitectura de Software

### Definición y Propósito
- **¿Qué es?**: El modelado de arquitectura de software es el proceso sistemático de crear representaciones visuales, gráficas y documentadas de la estructura, componentes, relaciones y comportamientos de un sistema de software.

- **Objetivos principales**:
  - **Comunicación**: Facilitar el entendimiento entre stakeholders técnicos y no técnicos
  - **Planificación**: Identificar componentes, dependencias y flujos antes de la implementación
  - **Validación**: Detectar inconsistencias, problemas y riesgos en etapas tempranas
  - **Documentación**: Crear un registro permanente de decisiones arquitectónicas
  - **Análisis**: Evaluar diferentes alternativas de diseño

### Clasificación de Diagramas Arquitectónicos

#### 1. Diagramas de Estructura

**Diagrama de Componentes**
- **Propósito**: Muestra los componentes principales del sistema y sus interfaces de comunicación
- **Elementos**: Componentes, interfaces, dependencias, puertos
- **Cuándo usar**: Para entender la modularidad y las dependencias del sistema

```
Ejemplo - Sistema E-commerce:

┌─────────────────┐    ┌─────────────────┐    ┌─────────────────┐
│   Frontend UI   │◄──►│  API Gateway    │◄──►│   Auth Service  │
└─────────────────┘    └─────────────────┘    └─────────────────┘
                              │
                              ▼
┌─────────────────┐    ┌─────────────────┐    ┌─────────────────┐
│  Product Mgmt   │◄──►│ Business Logic  │◄──►│ Payment Service │
└─────────────────┘    └─────────────────┘    └─────────────────┘
         │                       │                       │
         ▼                       ▼                       ▼
┌─────────────────┐    ┌─────────────────┐    ┌─────────────────┐
│  Product DB     │    │   Orders DB     │    │   Payment DB    │
└─────────────────┘    └─────────────────┘    └─────────────────┘
```

**Diagrama de Clases**
- **Propósito**: Representa la estructura estática del sistema orientado a objetos
- **Elementos**: Clases, atributos, métodos, relaciones (herencia, composición, asociación)
- **Cuándo usar**: Para diseño detallado de la estructura de datos y comportamientos

```
Ejemplo - Sistema de Biblioteca:

┌─────────────────────┐         ┌─────────────────────┐
│      Usuario        │         │        Libro        │
├─────────────────────┤         ├─────────────────────┤
│ - id: int           │         │ - isbn: String      │
│ - nombre: String    │         │ - titulo: String    │
│ - email: String     │◄─────┐  │ - autor: String     │
│ - telefono: String  │      │  │ - disponible: bool  │
├─────────────────────┤      │  ├─────────────────────┤
│ + registrar()       │      │  │ + prestar()         │
│ + actualizarDatos() │      │  │ + devolver()        │
└─────────────────────┘      │  │ + buscar()          │
                             │  └─────────────────────┘
                             │
                    ┌─────────────────────┐
                    │      Préstamo       │
                    ├─────────────────────┤
                    │ - id: int           │
                    │ - fechaPrestamo     │
                    │ - fechaDevolucion   │
                    │ - estado: String    │
                    ├─────────────────────┤
                    │ + crear()           │
                    │ + extender()        │
                    │ + finalizar()       │
                    └─────────────────────┘
```

#### 2. Diagramas de Distribución

**Diagrama de Despliegue**
- **Propósito**: Representa la distribución física del software en hardware y la infraestructura
- **Elementos**: Nodos de hardware, componentes software, conexiones de red, protocolos
- **Cuándo usar**: Para planificar infraestructura, despliegue y distribución del sistema

```
Ejemplo - Aplicación Web Distribuida:

    ┌─────────────────┐     ┌─────────────────┐     ┌─────────────────┐
    │  Load Balancer  │     │   Web Server    │     │   Web Server    │
    │  (nginx)        │────▶│   (Node.js)     │     │   (Node.js)     │
    │ IP: 10.0.1.10   │     │ IP: 10.0.1.20   │     │ IP: 10.0.1.21   │
    └─────────────────┘     └─────────────────┘     └─────────────────┘
             │                       │                       │
             │                       └───────────────────────┼─── HTTP
             │                                               │
    ┌─────────────────┐              ┌─────────────────┐     │
    │   API Server    │◄─────────────┤  Database       │◄────┘
    │   (Express)     │   REST API   │  (PostgreSQL)   │
    │ IP: 10.0.2.10   │              │ IP: 10.0.3.10   │
    └─────────────────┘              └─────────────────┘
             │                                │
    ┌─────────────────┐              ┌─────────────────┐
    │   Cache Redis   │              │   File Storage  │
    │ IP: 10.0.2.20   │              │ IP: 10.0.3.20   │
    └─────────────────┘              └─────────────────┘
```

#### 3. Diagramas de Comportamiento

**Diagrama de Flujo de Datos**
- **Propósito**: Muestra cómo los datos fluyen a través del sistema entre procesos
- **Elementos**: Procesos, almacenes de datos, entidades externas, flujos de datos
- **Cuándo usar**: Para entender el procesamiento de información y transformación de datos

```
Ejemplo - Sistema de Procesamiento de Pedidos:

[Cliente] ──(Pedido)──▶ ┌─────────────┐ ──(Pedido validado)──▶ ┌─────────────┐
                        │   Validar   │                        │  Procesar   │
                        │   Pedido    │                        │   Pago      │
                        └─────────────┘                        └─────────────┘
                               │                                       │
                               ▼                                       ▼
                        ┌─────────────┐                        ┌─────────────┐
                        │   Catálogo  │                        │   Pagos     │
                        │    DB       │                        │    DB       │
                        └─────────────┘                        └─────────────┘
                                                                       │
          ┌─────────────┐ ◄──(Confirmación)── ┌─────────────┐ ◄───────┘
          │   Cliente   │                     │  Confirmar  │
          │             │ ──(Notificación)──▶ │   Pedido    │
          └─────────────┘                     └─────────────┘
                                                     │
                                                     ▼
                                              ┌─────────────┐
                                              │  Pedidos    │
                                              │     DB      │
                                              └─────────────┘
```

### Herramientas de Modelado

#### Herramientas Gratuitas
- **Draw.io/Diagrams.net**: Herramienta web gratuita, fácil de usar
- **PlantUML**: Generación de diagramas mediante código
- **Lucidchart** (versión gratuita): Colaborativa, integración con otras herramientas
- **Miro/Mural**: Para diagramas colaborativos y lluvia de ideas

#### Herramientas Profesionales
- **Enterprise Architect**: Completa suite para modelado empresarial
- **Visio**: Herramienta de Microsoft para diagramas técnicos
- **ArchiMate**: Para arquitectura empresarial
- **Visual Paradigm**: Suite completa de modelado UML y arquitectónico

### Mejores Prácticas del Modelado

#### Principios Fundamentales
1. **Simplicidad**: Mantener los diagramas lo más simples posibles
2. **Claridad**: Usar nombres descriptivos y leyendas cuando sea necesario
3. **Consistencia**: Mantener la misma notación a lo largo de todos los diagramas
4. **Propósito**: Cada diagrama debe tener un objetivo específico y audiencia clara
5. **Actualización**: Mantener los diagramas sincronizados con la implementación

#### Errores Comunes a Evitar
- Crear diagramas demasiado complejos o detallados
- No definir claramente la audiencia del diagrama
- Mezclar diferentes niveles de abstracción en un mismo diagrama
- No mantener los diagramas actualizados
- Usar notación inconsistente o no estándar

## Evaluación y selección de arquitecturas
- **Definición**: Es el proceso sistemático de analizar, comparar y seleccionar la arquitectura más adecuada según los requisitos específicos del proyecto, considerando factores técnicos, de negocio y operacionales.
- **Objetivo**: Minimizar riesgos arquitectónicos y maximizar el valor del sistema a largo plazo mediante decisiones fundamentadas.

### Criterios fundamentales para evaluar arquitecturas
- **Atributos de calidad (Quality Attributes)**:
  - **Escalabilidad**: Capacidad de crecer horizontalmente (más servidores) y verticalmente (más recursos por servidor)
  - **Mantenibilidad**: Facilidad para realizar cambios, correcciones y extensiones del código
  - **Rendimiento**: Eficiencia en tiempo de respuesta, throughput y uso de recursos
  - **Seguridad**: Protección contra amenazas, autenticación, autorización y encriptación
  - **Disponibilidad**: Tiempo de actividad del sistema (99.9%, 99.99%), tolerancia a fallos
  - **Usabilidad**: Experiencia del usuario, facilidad de uso e interfaces intuitivas
  - **Portabilidad**: Capacidad de funcionar en diferentes plataformas y entornos
  - **Interoperabilidad**: Facilidad de integración con otros sistemas existentes

- **Restricciones técnicas**:
  - **Presupuesto**: Costo de desarrollo, infraestructura y mantenimiento
  - **Tiempo**: Plazos de entrega y time-to-market
  - **Recursos humanos**: Experiencia del equipo con tecnologías específicas
  - **Tecnologías existentes**: Sistemas legacy que deben integrarse
  - **Normativas**: Regulaciones de la industria (GDPR, SOX, HIPAA)

### Métodos de evaluación arquitectónica
- **Evaluación cualitativa**: 
  - Basada en experiencia, conocimiento del dominio y mejores prácticas
  - Utiliza checklists, revisiones de expertos y análisis de casos similares
  - Ejemplo: "React es mejor para UI interactivas porque nuestro equipo tiene 3 años de experiencia"

- **Evaluación cuantitativa**: 
  - Basada en métricas objetivas, benchmarks y pruebas de rendimiento
  - Utiliza prototipos, simulaciones y análisis de datos históricos
  - Ejemplo: "Microservicios redujo latencia de 200ms a 50ms en pruebas de carga"

### Herramientas y metodologías de evaluación
- **ATAM (Architecture Tradeoff Analysis Method)**: 
  - Método estructurado para identificar riesgos y trade-offs arquitectónicos
  - Analiza cómo las decisiones arquitectónicas impactan los atributos de calidad
  - Proceso: Identificar escenarios → Analizar arquitectura → Encontrar puntos sensibles

- **CBAM (Cost Benefit Analysis Method)**: 
  - Evalúa el costo-beneficio de diferentes decisiones arquitectónicas
  - Prioriza mejoras según su impacto económico y técnico

- **SAAM (Software Architecture Analysis Method)**: 
  - Enfocado en analizar modificabilidad y mantenibilidad
  - Útil para sistemas que requieren cambios frecuentes

Decisión: Monolítico para MVP rápido, migrar a microservicios al escalar

### Proceso estructurado de selección arquitectónica
1. **Identificación de requisitos**:
   - Requisitos funcionales (qué debe hacer el sistema)
   - Requisitos no funcionales (cómo debe comportarse)
   - Restricciones del contexto (presupuesto, tiempo, equipo)

2. **Generación de opciones arquitectónicas**:
   - Lluvia de ideas con diferentes patrones y estilos
   - Investigación de soluciones en proyectos similares
   - Consideración de tecnologías emergentes vs maduras

3. **Evaluación comparativa**:
   - Matriz de criterios ponderados con pesos según prioridad del negocio
   - Prototipos de concepto para validar supuestos críticos
   - Análisis de riesgos y puntos de fallo potenciales

4. **Selección y validación final**:
   - Decisión basada en evidencia cuantitativa y cualitativa
   - Plan de migración si se requiere transición gradual
   - Definición de métricas para validar la decisión post-implementación

### Factores críticos que influyen en la selección
- **Tamaño del equipo**: Equipos pequeños (<5 personas) → monolítico, equipos grandes → microservicios
- **Experiencia tecnológica**: Usar tecnologías conocidas vs aprender nuevas (curva de aprendizaje)
- **Madurez del dominio**: Dominios bien entendidos → arquitecturas más complejas, dominios nuevos → simplicidad
- **Velocidad de cambio**: Cambios frecuentes → arquitecturas modulares, cambios raros → monolíticos
- **Criticidad del sistema**: Sistemas críticos → arquitecturas probadas, sistemas experimentales → tecnologías nuevas

### Importancia de una selección arquitectónica correcta
- **Impacto a largo plazo**: Las decisiones arquitectónicas son costosas de cambiar después
- **Productividad del equipo**: Arquitectura mal elegida reduce velocidad de desarrollo hasta 10x
- **Costo total de propiedad**: Incluye desarrollo, operación, mantenimiento y evolución
- **Ejemplo de impacto negativo**: Twitter migró de Ruby on Rails monolítico a arquitectura distribuida por problemas de escalabilidad, proceso que tomó años y millones de dólares

## Resumen Ejecutivo: Arquitectura de Software

- **Arquitectura de software**: Estructura fundamental del sistema que define componentes, relaciones y propiedades esenciales para cumplir requisitos, con importancia clave en escalabilidad, mantenibilidad, desempeño y reusabilidad del sistema
- **Estilos arquitectónicos en 4 categorías**: Comunicación (SOA, bus mensajes), Despliegue (cliente-servidor, N-tier), Dominio (DDD), Estructura (componentes, capas), con patrones principales como Monolítico, Microservicios, En capas y Cliente-servidor para organizar código real y planificar despliegue
- **Principios POO fundamentales**: Abstracción (ocultar complejidad), Encapsulación (proteger datos), Herencia (reutilizar código), Polimorfismo (objetos diferentes responden igual método), implementados mediante clases abstractas, interfaces, getters/setters y relaciones padre-hijo
- **Modelado arquitectónico**: Proceso sistemático para crear representaciones visuales con tipos de diagramas de Estructura (componentes, clases), Distribución (despliegue hardware), Comportamiento (flujo datos), usando herramientas gratuitas (Draw.io, PlantUML) o profesionales (Enterprise Architect, Visio)
- **Evaluación arquitectónica**: Proceso de selección considerando criterios de calidad (escalabilidad, rendimiento, seguridad, disponibilidad) y restricciones técnicas (presupuesto, tiempo, recursos), mediante métodos cualitativos (experiencia) y cuantitativos (métricas, benchmarks, prototipos)
- **Herramientas metodológicas especializadas**: ATAM (análisis trade-offs arquitectónicos), CBAM (análisis costo-beneficio decisiones), SAAM (modificabilidad sistemas), aplicadas en proceso estructurado de identificación requisitos, generación opciones, evaluación comparativa y selección fundamentada
- **Factores críticos determinantes**: Tamaño equipo (pequeños <5 → monolítico, grandes → microservicios), experiencia tecnológica (balance conocimiento/aprendizaje), madurez dominio (conocidos → complejidad, nuevos → simplicidad), velocidad cambio (frecuentes → modularidad), criticidad sistema (críticos → probados)
- **Proceso de decisión en 4 pasos**: 1) Identificación requisitos funcionales/no funcionales y restricciones, 2) Generación múltiples opciones e investigación soluciones similares, 3) Evaluación mediante matriz criterios ponderados y prototipos validación, 4) Selección fundamentada con plan migración y métricas validación post-implementación
- **Impacto y consecuencias críticas**: Decisiones arquitectónicas exponencialmente más costosas cambiar post-implementación, arquitectura inadecuada reduce velocidad desarrollo hasta 10x, costo total incluye desarrollo/operación/mantenimiento/evolución, casos reales como Twitter demuestran costo decisiones incorrectas (años, millones dólares migración monolítico→distribuido)



## Términos comunes
- Patrón de diseño: Solución reutilizable a un problema común en el diseño de software.
- Componente: es una unidad funcional del sistema.
- mvc: Modelo-Vista-Controlador, un patrón arquitectónico que separa la lógica de negocio, la interfaz de usuario y el control de flujo.
- mvp: Modelo-Vista-Presentador, similar a MVC, pero el Presentador maneja la lógica de presentación.
- mvvm: Modelo-Vista-ViewModel, un patrón que facilita la separación entre la lógica de negocio y la interfaz de usuario mediante el uso de data binding.
- Microservicios: Arquitectura que divide una aplicación en servicios pequeños e independientes que se comunican entre sí.
- escalabilidad: Capacidad de un sistema para manejar un aumento en la carga de trabajo o usuarios.
- escalabilidad horizontal: Añadir más máquinas o instancias para distribuir la carga, es todo lo que se refiere a "escalar hacia afuera".
- escalabilidad vertical: Mejorar la capacidad de una sola máquina (más CPU, RAM) para manejar más carga, es todo lo que se refiere a "escalar hacia arriba".
- dominio: Área específica de conocimiento o actividad dentro de un sistema.
- arquitectónico: Profesional encargado del diseño y supervisión de la arquitectura de software.
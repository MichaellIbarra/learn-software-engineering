# Introducción a Ingeneria de Software
- La ingenería de software es una disciplina más allá de la programación, implica uso de principios, métodologías para diseñar, desarrollar, mantener y gestionar sistemas de software complejos, vendría ser los cimientos para crear software de alta calidad.

## Componentes clave
- **Requisitos**: Definición de lo que el software debe hacer.
- **Diseño**: Creación de la estructura y componentes del software.
- **Codificación**: Implementación del diseño en código.
- **Pruebas**: Verificación de que el software cumple con los requisitos.
- **Mantenimiento**: Actualización y mejora del software después de su lanzamiento.

## Importancia de las bases
- **Eficiencia**: Optimización de recursos y tiempo.
- **Calidad**: Mejora la confiabilidad y el rendimiento del software.
- **Escabilidad**: Facilita la expansión y adaptación del software a nuevas necesidades.
- **Mantenibilidad**: Simplifica el mantenimiento y actualización del software.

## Diferencia entre Software y Hardware
- **Software**: Conjunto de instrucciones y datos que permiten a una computadora realizar tareas específicas. Es intangible y puede ser modificado fácilmente.
- **Hardware**: Componentes físicos de una computadora, como el procesador, memoria y dispositivos de almacenamiento. Es tangible y su modificación requiere cambios físicos.

## Relación entre Software y Hardware
- EL hardware necesita del software para funcionar, y el software necesita del hardware para ejecutarse. Ambos trabajan juntos para proporcionar una experiencia informática completa.

## Tipos de Software
- **Software de sistema**: Gestiona los recursos del hardware y proporciona servicios básicos para otras aplicaciones (ej. sistemas operativos, controladores de dispositivos).
- **Software de aplicación**: Diseñado para ayuddar al usuario a realizar tareas específicas (ej. procesadores de texto, navegadores web, aplicaciones de mensajería).
- **Software embebido**: Software que está diseñado para controlar dispositivos específicos y está integrado en el hardware (ej. software en electrodomésticos, automóviles).
- **Software de desarrollo**: Herramientas utilizadas por programadores para crear, depurar y mantener otros programas. (ej. entornos de desarrollo integrado, compiladores).
- **Software de red**: Facilita la comunicación entre diferentes dispositivos en una red (ej. protocolos de red, software de gestión de redes).
- **Software de entretenAimiento**: Diseñado para el entretenimiento de streaming, reproductores multimedia, videojuegos).

## Ciclos de vida básico del software
- el ciclo de vida del software es el proceso que abarca todas las etapas desde la concepción hasta la retirada del software. Incluye fases como:
    - **FASE 1 - Planificación**: Definición de objetivos y requerimientos, análisis de viabilidad y planificación del proyecto. (ej. crear un cronograma de desarrollo y definir el alcance del proyecto).
    - **FASE 2 - Análisis y diseño**: Análisis de los requerimientos y diseño de la arquitectura del software, creación de diagramas y modelos. (ej. diseñar la estructura de la base de datos y la interfaz de usuario).
    - **FASE 3 - Desarrollo e implementación**: Codificación del software según el diseño, implementación del software en un entorno de pruebas. (ej. escribir el código fuente y realizar pruebas desarrollo).
    - **FASE 4 - Pruebas y validación**: Evaluación de la funcionalidad, rendimiento y seguridad del software, corrección de errores y ajustes finales. (ej. realizar pruebas de usabilidad y corregir errores detectados).
    - **FASE 5 - Implementación y mantenimiento**: Despliegue del software para el usuario final, mantenimiento continuo, incluyendo actualizaciones y correcciónes de errores. (ej. lanzar la aplicación en una tienda de aplicaciones y liberar actualizaciones periódicas).
    - **FASE 6 - Retiro**: Decisión de descontinuar el software, migración a nueva tecnologías o versiones. (ej. notificar a los usuarios sobre el fin del soporte y proporcionar opciones de migración).

## Ciclos de vida del proyecto de software
- Su ciclo de vida del proyecto de software abarca todas las fases que un proyecto atraviesa desde su inicio hasta su conclusión, este ciclo es ensencial para la area administrativa. Incluye:
    - **FASE 1 - Iniciación del proyecto**: Definir los objetivos del proyecto, identificar a los interesados y determinar la viabilidad del proyecto. (ej. creación de un documento de proyecto inicial que describa el propósito y alcance del proyecto).
    - **FASE 2 - Planificación del Proyecto**: Crear un plan detallado que incluya el alcance, cronograma, presupuesto y recursos necesarios. Establecer hitos y puntos de control para medir el progreso. (ej. desarrollo de un cronograma con fechas de entrega por cada fase del proyecto, usar diagramas de Gantt para visualizar el progreso).
    - **FASE 3 - Ejecución del Proyecto**: Implementar el plan de proyecto, coordinar a los equipos y gestionar los recursos para cumplir con los objetivos establecidos. (ej. los desarrolladores comienzan a escribir el código y el equipo de pruebas prepara los casos de prueba).
    - **FASE 4 - Monitoreo y Control del Proyecto**: Supervisar el progreso del proyecto. Indentificar y gestionar riesgos, asegurar que el proyecto se mantenga dentro del alcance y presupuesto. (ej. revisiones regulares del proyecto para asegurarse de que todo avanza según lo planeado, ajustar el cronograma si es necesario).
    - **FASE 5 - Cierre del Proyecto**: Concluir todas las actividades del proyecto. Documentar los resultados y realaizar una evaluación final del proyecto. (ej. presentación del software finalizado al cliente y entrega de la documentación del proyecto).

## Software de legado y su manejos
- El software de legado se refiere a sistemas o aplicaciones antiguos que sigue en uso, pero que han quedado desactualizados en comparación con las tecnologías actuales. A menudo, son cruciales para las operacioones de una organización. (ej. un banco que todavía utiliza un sistema de gestión de cuentas desarrollado hace 20 años).
    ### Desafíos del software de legado
    - Mantenimiento complicado: El código puede ser difícil de entender y modificar debido a la falta de documentación o a tecnologías obsoletas.
    - Compatibilidad limitada: Problemas al integrarse con sistemas modernos.
    - Falta de soporte: Herramentas y tecnologías que ya no se actualizan.
    - (ej. dificultad para encontrar desarrolladores que conozca los lenguajes de programación obsolestos).
    ### Importancia del software de legado
    - Operaciones críticas: Muchos sistemas de legado manejan funciones esenciales que no puede ser interrumpidas.
    - Alto costo de reemplaza: Reemplazar completamente un sistema de legado puede ser muy costoso y arriesgado.
    - (ej. un sistema de reservas de vuelos que ha sido operativo por décadas y es fundamental para la aerolínea).
    ## Estrategias para manejar el software de legado
    - Encapsulación: Crear una interfaz que permita que el sistema de legado interactúe con nuevas aplicaciones sin modificar el código original.
    - Modernización: Refactorizar o reescribir parte del código para mejorar su funcionalidad.
    - Reemplazo gradual: Sustituir el sistema de legado a fases controladas para minimizar riesgos.
    - (ej. migrar módulos de un sistema de gestión de inventarios a una nueva plataforma mientras se sigue utilizando el sistema antiguo para otras funciones).
    ### Herramientas para manejar del software de legado
    - Wrappers: Herramientas que permiten a sistemas modernos interactuar con software de legado.
    - Monitoreo: Soluciones para supervisar el rendimiento y la estabilidad del software de legado.
    - Automatización: Herramientas para automatizar tareas repetitivas y reducir el riesgo de errores humanos.
    - (ej. uso de una herramienta de monitoreo para detectar cuellos de botella de un sistema de legado).

## Requisitos de Software
- Los requisitos de software son las características y funciones que un sistema debe cumplir para satisfacer las necesidades de sus usuarios y stakeholders (partes interesadas). Se dividen en dos categorías: requisitos funcionales y no funcionales.
- Es la disciplina que se encarga de identificar, documentar y gestionar los requisitos de un sistema, implica la colaboración con los stakeholders para asegurar que el producto final cumpla con sus expectativas.
    ### Requisitos funcionales
    - Describen lo que el sistema debe hacer, incluyen funcionalidades, comportamientos y características específicas.
    - (ej. un sistema de comercio electrónico, un requisito funcional sería permitir a los usuarios realizar compras en línea).
    ### Requisitos no funcionales
    - Describen cómo el sistema debe comportarse, incluyen rendimiento, seguridad, usabilidad, entre otros, más que todo es crucial para la experiencia del usuario y la calidad del software.
    - (ej. en el mismo sistema de comercio electrónico, un requisito no funciona podría ser que la página cargue en menos de 3 segundos).
    ### Importancia de los requisitos de software
    - Aseguran que el producto final cumpla con las expectativas del cliente.
    - Evitan malentendidos y errores en las etapas posteriores del desarrollo.
    - (ej. un proyecto de software sin requisitos claros puede llevar a un producto final que no satisface las necesidades del cliente).

## Fases de la ingeniería de requisitos
- Elicitación: Recopilación de requisitos a través de entrevistas, cuestionarios y talleres con los stakeholders, etc.
- Análisis: Evaluación y refinamiento de los requisitos.
- Documentación: Registro formal de los requisitos en un formato claro y comprensible.
- Validación: Verificación de que los requisitos cumplen con las necesidades del cliente.
    ### Resumen y consejos prácticos
    - Resumen: Los requisitos de softwae son esenciales para definir las funcionalidades y comportamiento de un sistema, La ingeneria de requisitos es crucial para asegurar que el producto final cumpla con las expectativas del client y evite errores costosos.
    - Consejos prácticos:
        - Involucra a los stakeholders desde el principio para obtener una comprensión clara de sus necesidades.
        - Revisa y valida los requisitos continuamente durante el desarrollo del proyecto.
        - Documenta todo de manera clara y detallada.

## Técnicas básicas para la recopilación de requisitos
- Es importante la recopilación de requisitos es la base de un proyecto exitoso.
- Evita malentendidos y asegura que el producto final cumpla con las expectativas del cliente.
    ### Técnica 1: Entrevistas
    - Una de las técnicas más comunes para recopilar requisitos.
    - Permite obtener información directa de los stakeholders.
    - (ej. entrevistar al jefe de ventas para entender las necesidades de un sistema CRM).
    ### Técnica 2: Cuestionarios y encuestas
    - Cuestionarios y encuentas: útiles para recopilar información de un gran número de personas.
    - Permiten obtener datos cuantitativos y cualitativos.
    - (ej. enviar un cuestionario a todos los empleados para identificar las funcionalidades más destacadas en nuevo nuevo sistema de recursos humanos).
    ### Técnica 3: Observación
    - Consiste en observar a los usarios en su entorno de trabajo.
    - Permite identificar necesidades no expresadas verbalmente.
    - (ej. observar a los operados de manquinaria en una planta para detectar mejoras posibles en el software de control).
    ### Técnica 4: Revisión de documentos
    - Consiste en analizar la documentación existente para extraer requisitos.
    - Útil para proyectos que manejan sistemas o procesos ya establecidos
    - (ej. revisar manuales de usuario y documentación técnica de un sistema legado para identificar requisitos actuales).
    ### Técnica 5: Talleres de requisitos
    - Reuniones estructuradas donde los stakeholders colaboran para definir requisitos.
    - Fomentan la interacción y aseguran que todas las voces sean escuchadas.
    - (ej. un taller para definir los requisitos de un nuevo sistema de gestión de inventarios con la participación de todos los departamentos involucrados).

## Análisis de requisitos
- Proceso de entender y clarificar los requisitos recopilados.
- Identifica inconsistencias, ambigüedades y áreas de mejora.
    ### Ténicas de análisis de requisitos
    - Modelado de requisitos: crear diagramas y modelos para visualizar requisitos.
    - Análisis de casos de uso: Definir cómo los usuarios interactuarán con el sistema.
    - Revisión de requisitos: Reuniones para discutir y revisar lso requisitos con los stakeholders.
    ### Qué es la priorización de requisitos?
    - Determinar la importancia y urgencia de cada requisito.
    - Asegurar que los requisitos más críticos se aborden primero.
    ### Métodos de priorización de requisitos
    - Matriz de prioridad: Clasificación de requisitos en categorías como "alto", "medio" y "bajo".
    - Método MoSCoW: Clasificación en "Must have" (debe tener), "Should have" (debería tener), "Could have" (podría tener) y "Won't have" (no tendrá).
    - Análisis de valor: Evaluar el valor de cada requisito aporta al negocio.
    ### Ejemplo de priorización de requisitos
    - Desarrollo de una aplicación móvil para gestionar tareas.
    - Requisitos: Notifiaciones push, integración con calendario, tema oscuro.
    - Priorización:
        - Must have: Notificaciones push (esencial para la funcionalidad principal).
        - Should have: Integración con calendario (mejora la experiencia del usuario).
        - Could have: Tema oscuro (característica adicional, no esencial).
    ### Herramientas para el análisis y priorización de requisitos
    - Herramientas:
    - JIRA: Para seguimiento y gestión de requisitos.
    - Trello: para organizar requisitos en tableros visuales.
    - Confluence: Para documentación colaborativa de requisitos.
    ### Resumen y consejos prácticos
    - Resumen: 
    - Análisis: Entender y clarificar requisitos.
    - Priorización: Determinar importancia y urgencia.
    - Consejos prácticos: usa ténicas adecuadas, mantén la comunicación con stakeholders, revisa y ajusta prioridades regularmente.

## Qué es el estándar IEEE 830?
- Un estándar para la especificación de requisitos de software desarrollado por el Instituto de Ingenieros Eléctricos y Electrónicos (IEEE).
- Proporciona una guía estructurada para documentar requisitos de manera clara y coherente.
    ### Estructura del estándar IEEE 830
    - Estructura:
    - 1. Introducción: Propósito, alcance y definiciones.
    - 2. Descripción general: Perspectiva del producto, características del usuario.
    - 3. Requisitos específicos: Requisitos funcionales y no funcionales detallados.
    - 4. Anexos: Información adicional, definiciones de terminos.
    ### Sección 1: Introducción
    - Propósito: ¿Por qué está creando el software?
    - Alcance: ¿Qué cubrirá y qué no cubrirá el software?
    - Definiciones: Términos clave y acrónimos utilizados en el documento.
    ### Sección 2: Descripción general
    - Perspectiva del producto: Cómo se integra el software en el entorno existente.
    - Funciones del producto: Descripción de las funciones que el software debe realizar-
    - Características del usuario: Expectativas y necesidades del usuario finales.
    ### Sección 3: Requisitos específicos
    - Requisitos funcionales: Qué debe hacer el software (ej. procesamiento de datos, generación de informes).
    - Requisitos no funcionales: Cómo debe comportarse el software (ej. rendimiento, seguridad).
    ### Ejemplo práctico de especificación IEEE 830
    - Propósito: Sistema de gestión de inventarios.
    - Funciones: Registro de entradas y salidas, generación de informes.
    - Requisitos funcionales: Debe permitir registrar entradas de inventario.
    - Requisitos no funcionales: El sistema debe responder en menos de 2 segundos.

### Qué es un SRS?
- Un SRS (Software Requirements Specification) es un documento que describe los requisitos del software
- Actúa como un acuerdo entre los stakeholders y el equipo de desarrollo.
    ### Importancia del SRS
    - Claridad: Define claramente lo que se espera del software.
    - Comunicación: Facilita la comunicación entre stakeholders y desarrolladores.
    - Prevención de errores: Reduce la probabilidad de malentendidos y errores.
    ### Estructura de un SRS
    - Estructura:
    - Introducción: Propósito, alcance y definiciones.
    - Descripción general: Perspectiva del producto, funciones, características del usuario.
    - Requisitos específicos: Requisitos funcionales y no funcionales detallados.
    ### Sección 1: Introducción
    - Propósito: ¿Qué objetivo tiene el software?
    - Alcance: ¿Qué cubrirá y que no cubrira el software?
    - Definiciones: Términos clave y acrónimos utilizados en el documento.
    ### Sección 2: Descripción general
    - Perspectiva del producto: ¿Cómo encaja el software en el entorno actual?
    - Funciones del producto: ¿Qué debe hacer el software?
    - Características del usuario: ¿Quiénes son los usuarios finales y cuáles son sus necesidades?
    ### Sección 3: Requisitos específicos
    - Requisitos funcionales: Describen las funciones específicas que el software debe realizar.
    - Requisitos no funcionales: Definen atributos como rendimiento, seguridad y usabilidad.
    ### Ejemplo práctico de SRS
    - Propósito: Sistema de reservas de hotel.
    - Funciones: Reserva de habitacione, gestión de pagos, generación de informes.
    - Requisitos funcionales: Debe permitir la reserva de habitaciones en línea.
    - Requisitos no funcionales: El sistema debe tener un tiempo de respuesta de menos 1 segundo.
### Implementación de los requisitos en el desarrollo de software
- Los requisitos de software son la base para el desarrollo exitoso de cualquier proyecto de software.
- Aseguran que el producto final cumpla con las expectativas del cliente y los usuarios finales
    ### Procesos para implementar los requisitos
    - 1. Revisión de requisitos: Analizar los requisitos especificados en el SRS.
    - 2. Diseño de soluciones: Crear un diseño basado en los requisitos.
    - 3. Implementación: Codificar según el diseño y los requisitos.
    - 4. Verificación: Asegurarse de que el software cumple con los requisitos.
    ### Revisión de requisitos
    - Compresión: Leer y entender cada requisito del SRS.
    - Identificación de dependencias: Verificar interrelaciones entre requisitos.
    - Clarificación: Resolver cualquier ambigüedad con stakeholders.
    ### Diseño de soluciones
    - Modelado: Crear diagramas y modelos que representen la solución.
    - Especificación: Detallar cómo cada requisito se implementará en el diseño.
    - Revisión: Validar el diseño con los requisitos del SRS.
    ### Implementación del diseño
    - Codificación: Desarrollar el software según el diseño.
    - Integración: Combinar diferentes componentes del software.
    - Documentación: Mantener registro de la implementación.
    ### Verificación de requisitos
    - Pruebas: Realizar pruebas para verificar que los requisitos se cumplen.
    - Revisión: Revisar el software con los stakeholders para confirmar el cumplimiento.
    - Ajustes: Hacer ajustes según los resultados de las pruebas y revisiones.
    ### Ejemplo práctico de implementación
    - Requisito: El sistema debe permitir a los usuarios registrarse en línea.
    - Diseño: Crear un formulario de registro en la interfaz de usuario.
    - Implementación: Codificar el formulario y vincular con la base de datos.
    - Verificación: Probar el formulario y asegurar que los datos se guarden correctamente.

### Principios de diseño de software
- Los principios básicos de diseño de software son directrices que ayudan a crear sistemas de software eficientes, mantenibles y escalables.
    ### Principio de Responsabilidad Única (SRP - Single Responsibility Principle)
    - Cada módulo o clase debe tener una única razón para cambiar.
    - beneficio: Mejora la mantenibilidad y reduce el riesgo de errores.
    ```python
    # ❌ Malo: Una clase con múltiples responsabilidades
    class Usuario:
        def guardar_en_bd(self):
            pass  # Responsabilidad de persistencia
        def enviar_email(self):
            pass  # Responsabilidad de comunicación
    
    # ✅ Bueno: Separar responsabilidades
    class Usuario:
        def __init__(self, nombre):
            self.nombre = nombre
    
    class UsuarioRepository:
        def guardar(self, usuario):
            print(f"Guardando {usuario.nombre} en BD")
    
    class EmailService:
        def enviar(self, usuario, mensaje):
            print(f"Email enviado a {usuario.nombre}")
    ```
    ### Principio de Abierto/Cerrado (OCP - Open/Closed Principle)
    - Los módulos deben estar abierto para su extesión, pero cerrados para su modificación.
    - Beneficios: Permite añadir nuevas funcionalidades sin alterar el código existente.
    ```python
    from abc import ABC, abstractmethod
    
    class Forma(ABC):
        @abstractmethod
        def area(self):
            pass
    
    class Rectangulo(Forma):
        def __init__(self, ancho, alto):
            self.ancho = ancho
            self.alto = alto
        
        def area(self):
            return self.ancho * self.alto
    
    class Circulo(Forma):
        def __init__(self, radio):
            self.radio = radio
        
        def area(self):
            return 3.14159 * self.radio ** 2
    
    # Uso: Agregar nuevas formas sin modificar código existente
    def calcular_area_total(formas):
        return sum(forma.area() for forma in formas)
    ```
    ### Principio de Sustitución de Liskov (LSP - Liskov Substitution Principle)
    - Los objetos de una clase derivada deben poder sustituirse por objetos de la clase base sin afectar la funcionalidad.
    - Beneficios: Garantiza que las subclases sean intercambiables sus superclases.
    ```python
    class Ave:
        def volar(self):
            return "Volando..."
    
    class Aguila(Ave):
        def volar(self):
            return "Águila volando alto"
    
    class Paloma(Ave):
        def volar(self):
            return "Paloma volando suavemente"
    
    # ✅ Funciona correctamente - cualquier Ave puede volar
    def hacer_volar(ave: Ave):
        return ave.volar()
    
    # Uso: Las subclases son intercambiables
    aguila = Aguila()
    paloma = Paloma()
    
    print(hacer_volar(aguila))  # Funciona
    print(hacer_volar(paloma))  # Funciona igual
    ```
    ### Principio de Segregación de Interfaces (ISP - Interface Segregation Principle)
    - Los clientes no deben verses obligados a depender de la interfaces que no utilizan.
    - Beneficio: Evita interfaces grandes y poco flexibles, facilitando el mantenimiento.
    ```python
    from abc import ABC, abstractmethod
    
    # ✅ Bueno: Interfaces específicas y pequeñas
    class Imprimible(ABC):
        @abstractmethod
        def imprimir(self):
            pass
    
    class Escaneable(ABC):
        @abstractmethod
        def escanear(self):
            pass
    
    class ImpresoraSimple(Imprimible):
        def imprimir(self):
            return "Imprimiendo documento"
    
    class ImpresoraMultifuncion(Imprimible, Escaneable):
        def imprimir(self):
            return "Imprimiendo documento"
        
        def escanear(self):
            return "Escaneando documento"
    
    # Uso: Cada clase implementa solo lo que necesita
    ```
    ### Principio de Inversión de Dependencias (DIP - Dependency Inversion Principle)
    - Las dependencias deben ir hacia abstracciones, no hacia implementaciones concretas.
    - Beneficio: Permite una mayor flexibilidad y desacoplamiento en el diseño.
    ```python
    from abc import ABC, abstractmethod
    
    # Abstracción
    class ServicioNotificacion(ABC):
        @abstractmethod
        def enviar(self, mensaje):
            pass
    
    # Implementaciones concretas
    class EmailService(ServicioNotificacion):
        def enviar(self, mensaje):
            return f"Email: {mensaje}"
    
    class SMSService(ServicioNotificacion):
        def enviar(self, mensaje):
            return f"SMS: {mensaje}"
    
    # Clase de alto nivel depende de abstracción
    class GestorPedidos:
        def __init__(self, notificador: ServicioNotificacion):
            self.notificador = notificador
        
        def procesar_pedido(self):
            return self.notificador.enviar("Pedido procesado")
    
    # Uso: Fácil cambio de implementación
    gestor = GestorPedidos(EmailService())
    print(gestor.procesar_pedido())  # Usa email
    ```
    ### Ejemplos prácticos de principios de diseño
    - Ejemplo 1: Aplicación de e-commerce utilizando el principio de responsabilidad única para manejar pagos y usuarios en módulos separados.
    - Ejemplo 2: Uso de principio de abierto/cerrado para añadir nuevos métodos de pago sin modificar el código de procesamiento existente.
    - Ejemplo 3: Implementación del principio de sustitución de Liskov en una jerarquía de clases de productos, permitiendo que diferentes tipos de productos se manejen de manera uniforme.
    - Ejemplo 4: Aplicación del principio de segregación de interfaces para crear interfaces específicas para diferentes tipos de usuarios (administradores, clientes).
    - Ejemplo 5: Uso del principio de inversión de dependencias para permitir la inyección de dependencias en un sistema de notificaciones, facilitando el cambio entre diferentes servicios de notificación.

### Patrones de diseño comunes
- Los patrones de diseño son soluciones reusables a un problema común en el diseño de software.
- Beneficios: Proporciona soluciones probadas y bien documentas.
    ### Patrón Singleton
    - Asegura que una clase tenga una única instancia y proporciona un punto de acceso global a ella.
    - Beneficios: Controla el acceso a recursos compartidos y reduce el uso de memoria.
    - (ej. conexion a base de datos, configuración de aplicaciones).
    ```python
    class Database:
        _instance = None
        
        def __new__(cls):
            if cls._instance is None:
                cls._instance = super().__new__(cls)
            return cls._instance
    
    # Uso: Solo existe una conexión sin importar cuántas veces la crees
    db1 = Database()
    db2 = Database()
    print(db1 is db2)  # True - Es la misma instancia
    ```
    ### Patrón Factory Method
    - Define una interfaz para crear objetos, pero permite a las subclases decidir qué clase instanciar.
    - Beneficios: Facilita la creación de objetos sin depender de clases concretas.
    - (ej. creación de diferentes tipos de documentos en una aplicación de procesamiento de texto, como Word, PDF).
    ```python
    class DocumentFactory:
        @staticmethod
        def create_document(doc_type):
            if doc_type == "pdf":
                return PDFDocument()
            elif doc_type == "word":
                return WordDocument()
            
    # Uso: Crear documentos sin conocer la clase específica
    doc = DocumentFactory.create_document("pdf")
    doc.save()  # Guarda como PDF automáticamente
    ```
    ### Patrón Observer
    - Permite a un objeto notificar a otros objetos sobre cambios en su estado.
    - Beneficios: Facilita la comunicación entre objetos sin acoplarlos estrechamente.
    - (ej. sistema de notificaciones en una aplicación).
    ```python
    class Newsletter:
        def __init__(self):
            self._subscribers = []
            
        def subscribe(self, subscriber):
            self._subscribers.append(subscriber)
            
        def notify(self, message):
            for subscriber in self._subscribers:
                subscriber.update(message)
    
    class EmailSubscriber:
        def update(self, message):
            print(f"Email enviado: {message}")
    
    # Uso: Notifica automáticamente a todos los suscriptores
    newsletter = Newsletter()
    newsletter.subscribe(EmailSubscriber())
    newsletter.notify("¡Nueva publicación!")  # Todos reciben la notificación
    ```
    ### Patrón Strategy
    - Define una familia de algoritmos, encapsula cada uno y los hace intercambiables.
    - Beneficios: Permite cambiar el comportamiento de un objeto en tiempo de ejecución.
    - (ej. algoritmos de clasificación, QuickSort, MergeSort, etc).
    ```python
    class PaymentProcessor:
        def __init__(self, strategy):
            self._strategy = strategy
            
        def set_strategy(self, strategy):
            self._strategy = strategy
            
        def process_payment(self, amount):
            return self._strategy.pay(amount)
    
    class CreditCardPayment:
        def pay(self, amount):
            return f"Pagando ${amount} con tarjeta de crédito"
    
    class PayPalPayment:
        def pay(self, amount):
            return f"Pagando ${amount} con PayPal"
    
    # Uso: Cambiar algoritmo de pago en tiempo de ejecución
    processor = PaymentProcessor(CreditCardPayment())
    print(processor.process_payment(100))  # Tarjeta de crédito
    
    processor.set_strategy(PayPalPayment())
    print(processor.process_payment(100))  # PayPal
    ```
    ### Patrón Decorator
    - Permite añadir funcionalidades a un objeto de manera dinámica sin alterar su estructura.
    - Beneficios: Proporciona una manera flexible de estender el comportamiento de los objetos.
    - (ej. añadir funcionalidades adicionales a una ventana en una aplicación)
    ```python
    class Cafe:
        def costo(self):
            return 5
        
        def descripcion(self):
            return "Café simple"
    
    class DecoradorCafe:
        def __init__(self, cafe):
            self._cafe = cafe
            
        def costo(self):
            return self._cafe.costo()
            
        def descripcion(self):
            return self._cafe.descripcion()
    
    class Leche(DecoradorCafe):
        def costo(self):
            return self._cafe.costo() + 2
            
        def descripcion(self):
            return self._cafe.descripcion() + " + Leche"
    
    class Azucar(DecoradorCafe):
        def costo(self):
            return self._cafe.costo() + 1
            
        def descripcion(self):
            return self._cafe.descripcion() + " + Azúcar"
    
    # Uso: Agregar funcionalidades dinámicamente
    cafe = Cafe()
    cafe_con_leche = Leche(cafe)
    cafe_completo = Azucar(cafe_con_leche)
    
    print(cafe_completo.descripcion())  # "Café simple + Leche + Azúcar"
    print(f"Costo: ${cafe_completo.costo()}")  # Costo: $8
    ```
    ### Ejemplo práctico de patrones de diseño
    - Ejemplo 1: Implementación del patrón Singleton para la configuración global de una aplicación
    - Ejemplo 2: Uso del patrón Factory Method para crear diferentes tipos de notificaciones (email, SMS).
    - Ejemplo 3: Aplicación del patrón Observer para un sistema de actualización en tiempo real.
    - Ejemplo 4: Implementación del patrón Strategy para diferentes algoritmos de compresión de datos, ya que permite cambiar el algoritmo según las necesidades, ejemplo ZIP, RAR.
    - Ejemplo 5: Uso del patrón Decorator para añadir funcionalidades adicionales a un objeto de manera dinámica, como agregar características a un producto en una tienda en línea (ej. envoltura de regalo, envío rápido).
    ### Consejos para aplicar patrones de diseño
    - Evalúa las necesidades: elige el patrón adecuado para el problema específico.
    - Mantén la simplicidad: No uses patrones inncesarios, mantén el diseño simple.
    - Documenta: Registra el uso de patrones y su propósito.

### Diseño de interfaces de usuario
- Qué es el interfaz de usuario?: es el punto de interacción entre el usuario y el sistema.
- Importancia: Afecta la usabilidad y la satisfacción del usuario.
    ### Principios de diseño de interfaces
    - Simplicidad: Mantén las interfaces limpias y libres de elementos innecesarios.
    - Consistencia: Usa elementos de diseño y comportamiento coherentes.
    - Retroalimentación: Proporciona respuestas claras a las acciones del usuario.
    - Accesibilidad: Asegúrate de que la interfaz sea usable para todos los usuarios.
    ### Diseño centrado en el usuario
    - Diseño que prioriza las necesidades y comportamientos del usuario.
    - Beneficio: Mejora la usabilidad y la experiencia del usuario.
    - (ej. creación de perfiles de usuario para adaptadar la interfaz a diferentes necesidades).
    ### Ejemplo de diseño de interfaz
    - Elementos: Botones, menús, formularios.
    - Principios aplicados:
    - Simplicidad: Diseño limpio con espacio en blanco adecuado.
    - Consistencia: Uso de colores coherentes en toda la interfaz.
    - Retroalimentación: Mensajes claros al completar acciones.
    - Accesibilidad: Texto legible y opciones de contraste alto.
    ### Ejemplo de propotipo interactivo
    - Un propotipo interactivo muestra cómo los usuarios interactúan con la interfaz.
    - Beneficio: Permite probar y ajustar el diseño antes de la implementación.

### Documentación de diseño de software
- Es el registro detallado del diseño del software
- Propósito: Facilita la compresión, implementación y mantenimiento del sistema.
    ### Tipos de documentación de diseño
    - Documentación Técnica: Diagramas, especificaciones, arquitectura.
    - Documentación del Usuario: Manuales, guías de usuario.
    - Documentación de Desarrollo: Notas de desarrollo, comentarios en el código.
    ### Componentes clave de la documentación de diseño
    - Diagrama de arquitectura: Representa la estructura del sistema.
    - Especificaciones de componentes: Detalla las funcionalidades de cada componente.
    - Interfaz de usuario: Descripciones y ejemplos de las interfaces.
    ### Ejemplo de documentación de diseño - diagrama de arquitectura
    - Diagrama que muestra la estructura del sistema.
    - Beneficio: Ayuda a entender la relación entre componentes.
    ### Ejemplo de documentación de diseño - especificaciones de componentes
    - Detalles sobre la funcionalidad y diseño de cada componente.
    - Beneficio: Asegura que cada componente cumpla con los requisitos.
    ### Documentación de interfaz de usuario
    - Incluye descripciones de la interfaz y ejemplos visuales.
    - Beneficios: Facilita el desarrollo y la prueba de la interfaz.

### Principios de Jacob Nielsen para el desarrollo
- ¿Quién es Jacob Nielsen?: es un Experto en usabilidad y diseli de interfaces.
- Contribuciones: Principios de usabilidad para interfaces web.
    ### Principios de usabilidad de Jacob Nielsen
    - Visibilidad del estado del sistema: Mantener a los usuarios informados sobre lo que está ocurriendo.
    - Compatibilidad con el mundo real.
    - Control y libertad del usuario.
    - Consistencia y estándares.
    - Prevención de errores.
    - Reconocimiento en lugar de memorización.
    - Flexibilidad y eficiencia de uso.
    - Estética y diseño minimalista.
    - Ayuda a los usuarios a reconocer errores.
    - Ayuda y docmentación.
    ### Visibilidad del estado del sistema
    - El usuario debe saber qué está pasando en el sistema en todo momento.
    - Ej. Indicadores de carga, mensajes de confirmación.
    ### Compatibilidad con el mundo real
    - usa lenguaje, iconos y conceptos que sean familiares para los usuarios.
    - Ej. Menús y botones que imitan objetos físicos conocidos.
    ### Control y libertad del usuario
    - Permite a los usuarios deshacer y rehacer acciones fácilmente.
    - Ej. Botones de deshacer/rehacer en editores de texto.
    ### Consistencia y estándares
    - Mantén un diseño y comportamiento consistente a lo largo de la interfaz.
    - Ej. Uso uniforme de colores y botones.
    ### Prevención de errores
    - Diseña la interfaz para evitar errores en lugar de solo ofrecer mensajes de error.
    - Ej. Validación de formularios en tiempo real.
    ### Reconocimiento en lugar de memorización
    - Facilita el reconocimiento de opciones y funciones en lugar de requerir que los usuarios memoricen inforomación.
    - Ej. Menús desplegables y botones con iconos descriptivos.
    ### Flexibilidad y eficiencia de uso
    - Permite a los usuarios personalizar la interfaz para adaptarse a sus necesidades.
    - Ej. Atajos de teclaod y configuración personalizables como cambair de tema.
    ### Estética y diseño minimalista
    - El diseño debe ser estéticamente agradable y libre de elementos inncesarios.
    - Ej. Interfaces limpias con diseños minimalista.




## Términos comunes
- wrappers: Es una pieza de software que "envuelve" otra pieza de software para proporcionar una interfaz diferente o adicional, facilitando la interacción entre sistemas.
- refactorización: Es el proceso de reestructurar el código existente sin cambiar su comportamiento externo, con el objetivo de mejorar su legibilidad, mantenibilidad y rendimiento.
- stakeholders: Son todas las personas, grupos u organizaciones que tienen un interés o están afectados por un proyecto o sistema de software.
- Elicitación: Es el proceso de recopilar y definir los requisitos del software a través de la interacción con los stakeholders.
- Cuantitativos y cualitativos: Se refiere a dos tipos de datos; los cuantitativos son datos numéricos que pueden medirse y analizarse estadísticamente, mientras que los cualitativos son datos descriptivos que proporcionan información sobre características, atributos o cualidades.
- Acrónimos: Son palabras formadas por las letras iniciales de un conjunto de palabras, utilizadas para abreviar términos largos o complejos.
- Funcionalidades funcionales y no funcionales: Los requisitos funcionales describen lo que el sistema debe hacer, mientras que los requisitos no funcionales describen cómo debe comportarse el sistema en términos de rendimiento, seguridad, usabilidad, entre otros.
- Interfaz de clase: Es una definición que especifica un conjunto de métodos y propiedades que una clase debe implementar, sin definir cómo se implementan esos métodos.
- Propotipo: Es una representación preliminar de un producto o sistema que permite a los diseñadores y desarrolladores visualizar y probar conceptos antes de la implementación completa.
- MVP (Minimum Viable Product): Es la versión más básica de un producto que incluye solo las características esenciales necesarias para satisfacer a los primeros usuarios y obtener retroalimentación para futuras mejoras.

## Recursos
- https://ocw.unican.es/pluginfile.php/2168/course/section/1988/plantilla_formato_ieee830.pdf
- https://saga.so/95fc47a2-27bc-466f-b7ad-233940b499e9
- https://es.scribd.com/document/469148576/Plantilla-Proyecto-de-Desarrollo-de-Sw
- https://mpsm.gob.pe/public/mesavirtual/mv_2336_guia_para_la_documentacion_de_proyectos_de_software.pdf
- https://es.scribd.com/document/422195528/Guia-Para-La-Documentacion-de-Proyectos-2